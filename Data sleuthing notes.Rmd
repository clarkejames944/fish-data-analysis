---
title: "Data sleuthing notes"
author: "James Clarke"
date: "13 December 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First of all I want to look at the differences between the data_raw and data_derived files.
Data raw contains three datasets. These include:

*Average annual growth by zone
+includes the zone fish collected in, the associated annual average bottom temperature, estimate of population-wide average growth and the CI's associated with this

*Environmental data
+Includes the zone, it's associated lattitude and longitude, the average annual bottom temperature of each year, total catch in kg (not taking into account fishing effort) and zone specific catch per unit time (CPUE)- this can't be compared across zones as based on deviations from zone average

*tiger flathead data major zones
+Includes zone, batch, fish number and code (all of which can be ignored), the gear type, readability of the otolith, the capture year and month of the fish, port of landing (again ignore), Gender, fish length, age, otolith reader, the edge type of the otolith, radius of otolith, fish ID number, year of spawning, age associated with a particular increment and then the associated increment width and year of this increment. Additionally there is information on whether the individual is a juvenile or adult for a particular increment.

All of these have been assembled in the data derived spreadsheet arranged predominantly by fish ID, including two readings for the water temperature (although both appear to be identical throughout the data), and the logarithmic of the increment width has also been added in this.

#Variables that have continuous measurements for each individual fish
*'Age' -AdjAge possible to use for fixed measures for each fish
*'Year'
*'Increment'
*'CPUE'
*'totalcatch'
*'bottomtemp1' and 'bottomtemp2'
*'growth'
*'log_incr'

All the rest will be common for each fish- therefore make sure to group or you will obtain weird readings. For fish length and age must use AdjAge.


#Some interesting relationships found
+between fish length and radius
+between zones and increment length
+between zones and radius
+between zones and growth
+between zones and floorlength
+between areas and increment length
+between areas and radius
+between areas and growth
+between age and radius
+between age and fishlength
+between age and radius
+no difference between sex and age
+between temperature and growth

Could group by juvenile and adult separately to determine that effect on various relationships.

Extra information on tiger flathead form the Australian governments fishery page(https://www.afma.gov.au/fisheries-management/species/tiger-flathead)

#comments on some categorical variables

+zone
Four zones. EBS, ETAS, NSW, WTAS.
The majority of the data is obtained from the EBS zone

+gear
Two types. Danish seine and trawl.
The majority is carried out by trawling.
501 unknown values also.

+sex
most have positive gender ID. 3804 have unknown gender however.

+reader
5 different readers. The most common reader was Simon.

+edge type
most common are blank, 1, n or w. Very few are '4'.

+maturity
As mentioned by fede in his explanatory notes, juveniles seem to be categorised as all ages below 5 years old. However, the website says this species will reach sexual maturity between 3-5 years?? Fede didn't really use this variable though.

#Some comments on continuous variables
```{r}
summary(fish)
```

+For growth, upper and lower CIs there are a total of 6 missing values

+if using temperature use bottomtemp1 as it lacks the missing values(from the original data there should not be missing values)

+The latest record that we have is from 1971, although the mean is 2001. Latest is 2009.

+Increment. Some potential outliers. Max is 0.877 but mean is 0.21414.

+Fish length- max is 65, mean 40.12, min is 20. 72 missing values. Website says that they grow up to 70cm, and that females are generally larger than males.

+Age- website says they live up to 15 years and that females live longer than males. Apparantly in the adjusted age section the max value is 28. This seems unlikely though, however, in the notes it is said that this otolith is huge(although the fish length was not the biggest), it is also carried out by Simon, who is the most common reader. The next oldest is 25 and it has been noted for this one that it was difficult to read this otolith. Not sure where they get these values from the Age section though as only 15 increments were counted for the 28 year old fish and only 10 counted for the 25 year old one. Mean for AdjAge is 6.712. and min is 2 years old.

After looking at the AdjAge it is clear that this is in fact the difference between year at capture and year class. So is the true reading of age and does not necessarily conform with the Age variable which is the age from the increment counts- for older individuals in can be difficult to read the increments so presumably the first years are not included in the analysis. This is important to be considered for the analysis.


###The GAMs
The naming of the subsets
+EBS(m/f)= EBS zone male or female
+ETAS(m/f)
+NSW(m/f)
+WTAS(m/f)



##Some figures of the GAMs created and the associated Box-Cox transformations.
Box-Cox transformation was manual- transformation: x^(lambda)-1/lambda 

lambda was optimised using the NSWm subset and was found to be near 1.85 (so lambda=1.85 for the transformations of all the subsets), as shown below

```{r}
ggplot(NSWm, aes(x=prev))+
  geom_line(aes(y=res_box_preds1), colour="steelblue")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds1), label="lambda=-2")+
  geom_line(aes(y=res_box_preds2), colour="green")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds2), label="lambda=-1.5")+
  geom_line(aes(y=res_box_preds3), colour="red")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds3), label="lambda=-1")+
  geom_line(aes(y=res_box_preds4), colour="orange")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds4), label="lambda=-0.5")+
  geom_line(aes(y=res_box_preds6), colour="aquamarine")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds6), label="lambda=0.5")+
  geom_line(aes(y=res_box_preds7), colour="mediumorchid1")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds7), label="lambda=1")+
  geom_line(aes(y=res_box_preds8), colour="purple")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds8), label="lambda=1.5")+
  geom_line(aes(y=res_box_preds9), colour="cyan")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds9), label="lambda=2")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("Manual Box-Cox NSWm")+
  theme_classic()

ggplot(NSWm, aes(x=prev))+
  geom_line(aes(y=res_box_preds8), colour="purple")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds8), label="lambda=1.5")+
  geom_line(aes(y=res_box_preds9), colour="cyan")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_preds9), label="lambda=2")+
  geom_line(aes(y=res_box_predsA), colour="olivedrab")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_predsA), label="lambda=1.75")+
  geom_line(aes(y=res_box_predsB), colour="gray")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_predsB), label="lambda=1.85")+
  geom_line(aes(y=res_box_predsC), colour="steelblue")+
  geom_text(data=subset(NSWm, prev=='0.5'), aes(y=res_box_predsC), label="lambda=1.9")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("Manual Box-Cox NSWm")+
  theme_classic()
```

The optimum lambda value was also tested on the ETASm subset (as it displays an uneven best fit line with 1.85).
However it was still shown that the optimum would likely be around 1.85 anyway even if the line was not perfectly straight (as shown below)

```{r}
  ggplot(ETASm, aes(x=prev))+
    geom_line(aes(y=res_box_preds1), colour="steelblue")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds1), label="lambda=-2")+
    geom_line(aes(y=res_box_preds2), colour="green")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds2), label="lambda=-1.5")+
    geom_line(aes(y=res_box_preds3), colour="red")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds3), label="lambda=-1")+
    geom_line(aes(y=res_box_preds4), colour="orange")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds4), label="lambda=-0.5")+
    geom_line(aes(y=res_box_preds6), colour="aquamarine")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds6), label="lambda=0.5")+
    geom_line(aes(y=res_box_preds7), colour="mediumorchid1")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds7), label="lambda=1")+
    geom_line(aes(y=res_box_preds8), colour="purple")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds8), label="lambda=1.5")+
    geom_line(aes(y=res_box_preds9), colour="cyan")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds9), label="lambda=2")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASm")+
    theme_classic()

  ggplot(ETASm, aes(x=prev))+
    geom_line(aes(y=res_box_preds7), colour="mediumorchid1")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds7), label="lambda=1")+
    geom_line(aes(y=res_box_preds8), colour="orange")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds8), label="lambda=1.5")+
    geom_line(aes(y=res_box_preds9), colour="cyan")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds9), label="lambda=2")+
    geom_line(aes(y=res_box_preds), colour="steelblue")+
    geom_text(data=subset(ETASm, prev=='0.343'), aes(y=res_box_preds), label="lambda=1.85")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASm")+
    theme_classic()
  
```

#For the EBSm data first

```{r}
EBSm <- EBSm %>% mutate(preds=predict(EBSm_size_gam))
ggplot(EBSm,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
    geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("EBSm")+
  coord_fixed(ratio = 1)+
  theme_classic()

EBSm <- EBSm %>% mutate(res_preds=predict(EBSm_res_gam))
ggplot(EBSm,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("EBSm")+
  coord_fixed(ratio = 30)+
  theme_classic()

ggplot(EBSm,aes(x=prev, y=EBSm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox EBSm(lambda=1.85)")+
   coord_fixed(ratio = 1)+
    theme_classic()

  ggplot(EBSm,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox EBSm(lambda=1.85)")+
     coord_fixed(ratio = 30)+
    theme_classic()
  
   ggplot(EBSm,aes(x=EBSm_box_prev, y=EBSm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=EBSm_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox EBSm-transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
   
  ggplot(EBSm,aes(x=EBSm_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=EBSm_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox EBSm- transformed x")+
    coord_fixed(ratio = 30)+
    theme_classic()
  
   qqnorm(EBSm_res_box_orig1)
  qqline(EBSm_res_box_orig1)
```

#For EBSf

```{r}
EBSf <- EBSf %>% mutate(preds=predict(EBSf_size_gam))
ggplot(EBSf,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("EBSf")+
   coord_fixed(ratio = 1)+
  theme_classic()

EBSf <- EBSf %>% mutate(res_preds=predict(EBSf_res_gam))
ggplot(EBSf,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("EBSf")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(EBSf,aes(x=prev, y=EBSf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox EBSf (lambda=1.85)")+
   coord_fixed(ratio = 1)+
    theme_classic()

  ggplot(EBSf,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox EBSf (lambda=1.85)")+
     coord_fixed(ratio = 30)+
    theme_classic()
  
  ggplot(EBSf,aes(x=EBSf_box_prev, y=EBSf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=EBSf_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox EBSf-transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
  
   ggplot(EBSf,aes(x=EBSf_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=EBSf_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox EBSf-transformed x")+
    coord_fixed(ratio = 30)+
    theme_classic()
   
    qqnorm(EBSf_res_box_orig1)
  qqline(EBSf_res_box_orig1)
  
```

#For ETASm
```{r}
ggplot(ETASm,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("ETASm")+
   coord_fixed(ratio = 1)+
  theme_classic()

ETASm <- ETASm %>% mutate(res_preds=predict(ETASm_res_gam))
ggplot(ETASm,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("ETASm")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(ETASm,aes(x=prev, y=ETASm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASm (lambda=1.85)")+
   coord_fixed(ratio = 1)+
    theme_classic()

ggplot(ETASm,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASm (lambda=1.85)")+
   coord_fixed(ratio = 30)+
    theme_classic()

ggplot(ETASm,aes(x=ETASm_box_prev, y=ETASm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=ETASm_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox ETASm- transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()

ggplot(ETASm,aes(x=ETASm_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=ETASm_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox ETASm-transformed x")+
    coord_fixed(ratio = 100)+
    theme_classic()

 qqnorm(ETASm_res_box_orig1)
  qqline(ETASm_res_box_orig1)

```


#For ETASf
```{r}
ggplot(ETASf,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("ETASf")+
   coord_fixed(ratio = 1)+
  theme_classic()

ETASf <- ETASf %>% mutate(res_preds=predict(ETASf_res_gam))
ggplot(ETASf,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("ETASf")+
   coord_fixed(ratio = 30)+
  theme_classic()

 ggplot(ETASf,aes(x=prev, y=ETASf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASf (lambda=1.85)")+
    coord_fixed(ratio = 1)+
    theme_classic()

ggplot(ETASf,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox ETASf (lambda=1.85)")+
   coord_fixed(ratio = 30)+
    theme_classic()

  ggplot(ETASf,aes(x=ETASf_box_prev, y=ETASf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=ETASf_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox ETASf-transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
  
    ggplot(ETASf,aes(x=ETASf_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=ETASf_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox ETASf-transformed x")+
    coord_fixed(ratio = 75)+
    theme_classic()
    
      qqnorm(ETASf_res_box_orig1)
  qqline(ETASf_res_box_orig1)
```


#For NSWm

```{r}
NSWm <- NSWm %>% mutate(preds=predict(NSWm_size_gam))
ggplot(NSWm,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("NSWm")+
   coord_fixed(ratio = 1)+
  theme_classic()

NSWm <- NSWm %>% mutate(res_preds=predict(NSWm_res_gam))
ggplot(NSWm,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("NSWm")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(NSWm,aes(x=prev, y=oto_boxB))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=box_predsB), size=1.3, colour="steelblue")+
  ylab("Box Cox s'")+
  xlab("s")+
  ggtitle("Manual Box-Cox NSWm (lambda=1.85)")+
   coord_fixed(ratio = 1)+
  theme_classic()

ggplot(NSWm,aes(x=prev, y=res_box_sizeB))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_box_predsB), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("Manual Box-Cox NSWm (lambda=1.85)")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(NSWm,aes(x=NSWm_box_prev, y=oto_boxB))+
  geom_point(size=1)+
  geom_line(aes(x=NSWm_box_prev, y=box_preds1B), size=1.3, colour="steelblue")+
  ylab("Box Cox s'")+
  xlab("Box Cox s")+
  ggtitle("Manual Box-Cox NSWm-transformed x")+
  coord_fixed(ratio = 1)+
  theme_classic()

ggplot(NSWm,aes(x=NSWm_box_prev, y=res_box_size1B))+
  geom_point(size=1)+
  geom_line(aes(x=NSWm_box_prev, y=res_box_preds1B), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("Box Cox s")+
  ggtitle("Manual Box-Cox NSWm-transformed x")+
  coord_fixed(ratio = 30)+
  theme_classic()

  qqnorm(NSWm_res_box_orig1)
  qqline(NSWm_res_box_orig1)
```


#For NSWf
```{r}
NSWf <- NSWf %>% mutate(preds=predict(NSWf_size_gam))
ggplot(NSWf,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("NSWf")+
   coord_fixed(ratio = 1)+
  theme_classic()

NSWf <- NSWf %>% mutate(res_preds=predict(NSWf_res_gam))
ggplot(NSWf,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("NSWf")+
   coord_fixed(ratio = 30)+
  theme_classic()

 ggplot(NSWf,aes(x=prev, y=NSWf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox NSWf (lambda=1.85)")+
    coord_fixed(ratio = 1)+
    theme_classic()

  ggplot(NSWf,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox NSWf (lambda=1.85)")+
     coord_fixed(ratio = 30)+
    theme_classic()
  
   ggplot(NSWf,aes(x=NSWf_box_prev, y=NSWf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=NSWf_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox NSWf- transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
   
   ggplot(NSWf,aes(x=NSWf_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=NSWf_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox NSWf- transformed x")+
    coord_fixed(ratio = 30)+
    theme_classic()
   
   qqnorm(NSWf_res_box_orig1)
  qqline(NSWf_res_box_orig1)
  
```

#For WTASm
```{r}
WTASm <- WTASm %>% mutate(preds=predict(WTASm_size_gam))
ggplot(WTASm,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("WTASm")+
   coord_fixed(ratio = 1)+
  theme_classic()

WTASm <- WTASm %>% mutate(res_preds=predict(WTASm_res_gam))
ggplot(WTASm,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("WTASm")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(WTASm,aes(x=prev, y=WTASm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox WTASm (lambda=1.85)")+
   coord_fixed(ratio = 1)+
    theme_classic()

 ggplot(WTASm,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox WTASm (lambda=1.85)")+
    coord_fixed(ratio = 30)+
    theme_classic()
 
  ggplot(WTASm,aes(x=WTASm_box_prev, y=WTASm_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=WTASm_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox WTASm-transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
  
   ggplot(WTASm,aes(x=WTASm_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=WTASm_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox WTASm-transformed x")+
    coord_fixed(ratio = 30)+
    theme_classic()
   
     qqnorm(WTASm_res_box_orig1)
  qqline(WTASm_res_box_orig1)
  
```

#For WTASf
```{r}
WTASf <- WTASf %>% mutate(preds=predict(WTASf_size_gam))
ggplot(WTASf,aes(x=prev, y=oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=preds), size=1.3, colour="steelblue")+
  ylab("s'")+
  xlab("s")+
  ggtitle("WTASf")+
   coord_fixed(ratio = 1)+
  theme_classic()

WTASf <- WTASf %>% mutate(res_preds=predict(WTASf_res_gam))
ggplot(WTASf,aes(x=prev, y=res_oto_size))+
  geom_point(size=1)+
  geom_line(aes(x=prev, y=res_preds), size=1.3, colour="steelblue")+
  ylab("r^2")+
  xlab("s")+
  ggtitle("WTASf")+
   coord_fixed(ratio = 30)+
  theme_classic()

ggplot(WTASf,aes(x=prev, y=WTASf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=box_preds), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("s")+
    ggtitle("Manual Box-Cox WTASf (lambda=1.85)")+
   coord_fixed(ratio = 1)+
    theme_classic()

 ggplot(WTASf,aes(x=prev, y=res_box_size))+
    geom_point(size=1)+
    geom_line(aes(x=prev, y=res_box_preds), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("s")+
    ggtitle("Manual Box-Cox WTASf (lambda=1.85)")+
    coord_fixed(ratio = 30)+
    theme_classic()
 
  ggplot(WTASf,aes(x=WTASf_box_prev, y=WTASf_oto_box))+
    geom_point(size=1)+
    geom_line(aes(x=WTASf_box_prev, y=box_preds1), size=1.3, colour="steelblue")+
    ylab("Box Cox s'")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox WTASf-transformed x")+
    coord_fixed(ratio = 1)+
    theme_classic()
  
    ggplot(WTASf,aes(x=WTASf_box_prev, y=res_box_size1))+
    geom_point(size=1)+
    geom_line(aes(x=WTASf_box_prev, y=res_box_preds1), size=1.3, colour="steelblue")+
    ylab("r^2")+
    xlab("Box Cox s")+
    ggtitle("Manual Box-Cox WTASf-transformed x")+
    coord_fixed(ratio = 30)+
    theme_classic()
    
      qqnorm(WTASf_res_box_orig1)
  qqline(WTASf_res_box_orig1)
 
  
```


I think NSW, WTAS and EBS have been transformed well when lambda= 1.85 but perhaps the ETAS subsets need a different value of lambda.

Had a look at transforming the ETASm subset with a different lambda- but the same lambda value was needed it just doesn't want to go flat. But it is good enough.

To see if we can return to a more linear relationship within the data we also created some plots of a transformed x axis to plot against the transformed y-axis.
This does seem to provide us with more of a linear relationship in the data. 

Q-Q plots have also been added and the data doesn't really look normal.



It is now time to specify different distributions and link functions in the GAM to see if this helps the mean-variance relationship and distributional fit.
I will investigate the best combination to use using the EBSm subset.

First of all look at the data with the defaults
``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=gaussian(link="identity"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```


``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=gaussian(link="inverse"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```
``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=gaussian(link="log"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```


``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=quasi(link="log", variance = "constant"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```


``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=inverse.gaussian(link="log"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=inverse.gaussian(link="inverse"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=inverse.gaussian(link="1/mu^2"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=inverse.gaussian(link="identity"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=Gamma(link="log"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=Gamma(link="inverse"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```


``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=Gamma(link="identity"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
  
```

``` {r}
EBSm_size_ggam <- gam(EBSm$oto_size~EBSm$prev+s(EBSm$prev, k=50, by=EBSm$maturity), family=scat(link="log"))
 
  #plot the graph for EBSm
  EBSm <- EBSm %>% mutate(gpreds=predict(EBSm_size_ggam, type="response"))
  ggplot(EBSm,aes(x=prev))+
    geom_point(aes(y=oto_size, colour=maturity), size=1, alpha=0.1)+
    geom_abline(intercept=0, slope= 1)+
    geom_point(aes(y=gpreds), size=0.25, colour="steelblue")+
    ylab("s'")+ xlab("s")+
   ggtitle("EBSm")+
    theme_classic()
  
  
  ##extract residuals
  EBSm_res_orig = residuals(EBSm_size_ggam, type="response")
  ###log the residuals
  EBSm_res_size = log(EBSm_res_orig^2)

  
  ggplot(EBSm,aes(x=gpreds, y=EBSm_res_size))+
    geom_point(aes(colour=maturity), size=1, alpha=0.1)+
    geom_smooth(method='gam',
                formula = y~s(x, k=100), se=FALSE)+
    geom_smooth(method='lm',
                se=FALSE, linetype=2)

 
   #GAM of residuals for normality    
  EBSm_res_ggam <- gam(EBSm_res_size~s(EBSm$gpreds))
  
##Make some scaled residuals
  EBSm <- mutate(EBSm,
                       sc_resid = EBSm_res_orig / sqrt(exp(predict(EBSm_res_ggam))))
  
  ##Then make some qqplots (separting adult and juvenile)
  with(EBSm, car::qqp(sc_resid[maturity == "juvenile"])) 
  with(EBSm, car::qqp(sc_resid[maturity == "adult"])) 
  
```





Now time to have a go at a Stan model. To do this properly I feel that I should understand previous Stan code and seeing if I can apply it to my model.
From http://www.maths.bath.ac.uk/~jjf23/stan/ there are multiple examples to examine. I want to understand what they do with the yhat value as that is the complicated bit.
Basically fishID should be treated as a random effect and Age is nested within that. So I need to match that info with previous examples.

One fixed and one random effect:
for (i in 1:N)
    yhat[i] <- trt[treat[i]]+bld[blk[i]];
    
Split model: 
 for (i in 1:N)
    yhat[i] <- mu+ir2*irmeth2[i]+ir3*irmeth3[i]+ir4*irmeth4[i]+va2*var2[i]+fld[field[i]];
    
Nested model: (e.g. workers nested in a factory) (Age nested within FishID??)
 for (i in 1:Nobs)
    yhat[i] <- mu+ran1[levind1[i]]+ran2[levind2[i]]+ran3[levind3[i]];
    
Crossed model: (e.g. workers work in multiple factories)
  for (i in 1:N)
    yhat[i] <- trt[treat[i]] + bld1[blk1[i]] + bld2[blk2[i]];

Multilevel model: (hierarchical structure e.g. pupils within classes within schools(or ages of fish within zones))
  for (i in 1:Nobs)
    yhat[i] <- x[i]*beta+ran1[levind1[i]]+ran2[levind2[i]];

Longitudinal model:(several individuals and measurements are taken repeatedly on each individual over time)
 for (i in 1:Nobs)
    yhat[i] <- x[i]*beta+ranint[group[i]]+ranslope[group[i]]*timevar[i];
    
Repeated measures model: (several individuals and measurements are taken repeatedly on each individual, though time is not of interest)
  for (i in 1:Nobs)
    yhat[i] <- x[i]*beta+ran1[levind1[i]]+ran2[levind2[i]];

Multiple response multilevel model: (multilevel model in which there are more than one response variable of interest. e.g. the results to a maths AND english test )
  for (i in 1:Nobs)
    yhat[i] = x[i]*beta+ran1[levind1[i]]+ran2[levind2[i]]+ran3[levind3[i]];
    
    


Longitudinal model seems like the most suitable. Here is the full stan file for that one:
data {
     int<lower=0> Nobs;
     int<lower=0> Npreds;
     int<lower=0> Ngroups;
     vector[Nobs] y;
     matrix[Nobs,Npreds] x;
     vector[Nobs] timevar;
     int<lower=1,upper=Ngroups> group[Nobs];
}
parameters {
           vector[Npreds] beta;
           real<lower=0> sigmaint;
           real<lower=0> sigmaslope;
           real<lower=0> sigmaeps;

           vector[Ngroups] etaint;
           vector[Ngroups] etaslope;
}
transformed parameters {
  vector[Ngroups] ranint;
  vector[Ngroups] ranslope;
  vector[Nobs] yhat;

  ranint  <- sigmaint * etaint;
  ranslope  <- sigmaslope * etaslope;

  for (i in 1:Nobs)
    yhat[i] <- x[i]*beta+ranint[group[i]]+ranslope[group[i]]*timevar[i];

}
model {
  etaint ~ normal(0, 1);
  etaslope ~ normal(0, 1);
  y ~ normal(yhat, sigmaeps);
}

AND the associated rcode:

psid$cyear <- psid$year-78
lmod <- lm(log(income) ~ cyear*sex +age+educ, psid)
x <- model.matrix(lmod)
psiddat <- list(Nobs = nrow(psid),
                Npreds = ncol(x),
                Ngroups = length(unique(psid$person)),
                y = log(psid$income),
                x = x,
                timevar = psid$cyear,
                group = psid$person)
                
                
                

After specifying the Stan code and running the model in R I then had the opportunity to check the diagnostics of the model.
First of all I check one parameter to elucidate the health of the model e.g. for divergences
```{r}
color_scheme_set("mix-brightblue-gray")
mcmc_trace(posterior_fit, pars = "bp[271]", np = np_fit)

color_scheme_set("red")
mcmc_nuts_divergence(np_fit, lp_fit)
```


Now for the energy
```{r}
mcmc_nuts_energy(np_fit)
```

Now for the analysis of all the Rhat values and number of effective samples ratios for each of the parameters
```{r}
color_scheme_set("brightblue")
mcmc_rhat(rhats)

mcmc_neff(ratios_fit, size = 2)
```

Finally graph of the new predicted values on the orignal plotted values, as of the method in https://gist.github.com/mbjoseph/25d649e46602a419f9765638d5a2bfbc:

```{r}
plot(fishdat$prev, fishdat$oto_size, 
     xlab = 's', ylab = 's following')
for (i in seq_along(post$lp__)) {
  segments(x0 = min(fishdat$prev), x1 = post$bp[i], 
           y0 = post$intercept[i] + post$beta[i, 1] * min(fishdat$prev), 
           y1 = post$intercept[i] + post$beta[i, 1] * post$bp[i], 
           col = alpha(3, .1))
  segments(x1 = max(fishdat$prev), x0 = post$bp[i], 
           y1 = post$intercept[i] + 
             post$beta[i, 2] * (max(fishdat$prev) - post$bp[i]) + 
             post$beta[i, 1] * max(fishdat$prev), 
           y0 = post$intercept[i] + post$beta[i, 1] * post$bp[i], 
           col = alpha(2, .1))
}

points(fishdat$prev, fishdat$oto_size, pch = 19)

rug(post$bp)
```
